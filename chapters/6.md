# Chapter 6

# Monero deep

# Cryptography deep

Monero uses a wide variety of cryptographic primitives for various use cases.

Comparing to altcoins, Monero cryptography is considered conservative, sound and robust.

Comparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work. Some choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol (for more information about the CryptoNote protocol, look for ninth chapter).  

In this part, we will talk about address generation, blockchain and privacy more in depth than in the first chapters.

## Monero Pseudorandom Number Generation

Monero uses PRNG based on the Keccak hashing function. Basically, output of the previous hashing round is input for the next one.

The initial seed comes from entropy sources provided by operating system. On Linux and MacOS the seed comes from /dev/urandom. On Windows the WinAPI CryptGenRandom call is used for seeding.

This concerns the reference C++ implementation of Monero. Please note there are many alternative implementations of private key generation, including JavaScript, Python, Android/Java. These should be researched case by case for correctness.

## Hashing

For generating addresses (especially public address), it's important to hash keys.

Monero employs Keccak as a hashing function. In most contexts specifically Keccak-256 is used, providing 32-byte hashes.

Choosing a good hashing algorithm is a must for creating addresses in a secure way: if it generates the same addresses, there will be a "collision" (two people will have the same seed, so same private and public keys).

### Keccak
Keccak is the leading hashing function, designed by non-NSA designers. Keccak won NIST competition to become the official SHA3. It is used for transaction and block hashing.

## Base58

Base58 is a group of binary-to-text encoding schemes used to represent large integers as alphanumeric text. 

It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. 

It is therefore designed for human users who manually enter the data, copying from some visual source, but also allows easy copy and paste because a double-click will usually select the whole string.

Base58 Alphabet used in Monero:

123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

Note: Zero (0) along with the letters I (uppercase i), O (uppercase o), and l (lowercase L) are not present in this Base58 alphabet as they are the previously mentioned characters which might appear ambiguous.

# The relationships between seeds, address and keys

Before we get into the Monero deep, we have to introduce the concept of address generation.

## Elliptic curve

A finite field Fp where p is a prime number, is the field formed by the set {0, 1, 2, ..., p−1}. with arithmetic operations (+, ·) calculated.

Typically, elliptic curves are defined as the set of points (x, y) satisfying an equation:

y^2 = x^3 + ax + b

However, the cryptocurrency Monero uses a special curve known to offer improved security over other commonly used NIST curves, as well as excellent performance of cryptographic primitives.
The curve used belongs to the category of s.c. Twisted Edwards curves, which are commonly expressed as:
ax^2 + y^2 = 1 + dx^2y^2

## Ed25519 Function




## The address generation

# The Monero Blockchain 

Monero has a unique blockchain. We talked about what blockchain is and why it's important to have.
Basically Blockchain is a public ledger where each payments is. The Blockchain cannot be modified due to its nature. It is based on various cryptography protocols and algorithms in order to avoid any cheating.

## Lightning Memory Mapped Database

Monero is using LMDB databases to store its blockchain. Lightning Memory-Mapped Database (LMDB) is a software library that
provides a high-performance embedded transactional database in the form of a key-value store.

LMDB is written in C with API bindings for several programming languages and is developed by Howard Chu. LMDB stores arbitrary
key/data pairs as byte arrays, has a range-based search capability, supports multiple data items for a single key and has a special mode for appending records at the end of the database which gives a dramatic write performance increase over other similar stores.

LMDB is not a relational database but like Berkeley DB and other similar databases such as dbm is strictly a key-value store.

## Block structure

The block structure was defined by the third document of CryptoNote Standars. It defines the way data is stored within blocks and the blockhain along with the corresponding data structures.

A block consists of three parts:
* block header;
* base transaction body
* list of transaction identifiers.

The list starts with the number of transaction identifiers that it contains.

### Block Header

### Base Transaction

## Fees

# Privacy Transactions

## Stealth Addresses

Chapter 3 described a situation where Leo sent George some Monero and in doing so he used George's public keys to produce a one-time public key, also known as a stealth address, that is unlinkable to the George's real keys. This section will go deeper to explain the cryptography behind that one-time public key.

### Sending

The formula descibed in the CryptoNote whitepaper to produce this public output is `P = Hs(rA|i)G + B`. This means that when Leo wants to send Monero to George he generates a 256 bit pseudorandom scalar to be used as the transaction private key, r. Leo is the only person that will ever know this key, not even George. Leo then multiplies George's public view key, A,  by his pseudorandom scalar and then concatantes the output index, i, to resulting point. This data is then run through the `Hash to Scalar` function. This function takes the input data, hashes it using the Keccak-256 algorithm, then takes that resulting hash modulo the prime number 2^255 + 27742317777372353535851937790883648493. The ed25519 basepoint, G, is then multiplied by the scalar that is output from that function. Finally, Leo adds this point with George's public spend key, B, to produce the final output, P.

### Recieving

Now, as described in chapter 3, George must scan the blockchain for outputs that belong to him. To do this he must calculate `P' = Hs(aR|i)G + B`. The process is very similiar to what Leo had to do to send the Monero. George will get the public transaction key, R, used in the transaction from the blockchain and multiply it by his private view key, a. He then must concatenate the output index to the resulting point and that data through the `Hash to Scalar` function. He then multiplies the ed25519 basepoint, G, by the resulting scalar and finally adds his own public spend key, B, to the resulting point to produce the final point P'. If the output George generated independantly, P', matches the output from the blockchain, P, then George knows that he owns that output and can spend the associated Monero.

