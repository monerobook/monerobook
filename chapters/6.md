# Chapter 6

# Monero deep

# Cryptography deep

Monero uses a wide variety of cryptographic primitives for various use cases.

Comparing to altcoins, Monero cryptography is considered conservative, sound and robust.

Comparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work. Some choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol (for more information about the CryptoNote protocol, look for ninth chapter).  

In this part, we will talk about address generation, blockchain and privacy more in depth than in the first chapters.

## Monero Pseudorandom Number Generation

Monero uses PRNG based on the Keccak hashing function. Basically, output of the previous hashing round is input for the next one.

The initial seed comes from entropy sources provided by operating system. On Linux and MacOS the seed comes from /dev/urandom. On Windows the WinAPI CryptGenRandom call is used for seeding.

This concerns the reference C++ implementation of Monero. Please note there are many alternative implementations of private key generation, including JavaScript, Python, Android/Java. These should be researched case by case for correctness.

## Hashing

For generating addresses (especially public address), it's important to hash keys.

Monero employs Keccak as a hashing function. In most contexts specifically Keccak-256 is used, providing 32-byte hashes.

Choosing a good hashing algorithm is a must for creating addresses in a secure way: if it generates the same addresses, there will be a "collision" (two people will have the same seed, so same private and public keys).

### Keccak
Keccak is the leading hashing function, designed by non-NSA designers. Keccak won NIST competition to become the official SHA3. It is used for transaction and block hashing.

## Base58

Base58 is a group of binary-to-text encoding schemes used to represent large integers as alphanumeric text. 

It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. 

It is therefore designed for human users who manually enter the data, copying from some visual source, but also allows easy copy and paste because a double-click will usually select the whole string.

Base58 Alphabet used in Monero:

123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

Note: Zero (0) along with the letters I (uppercase i), O (uppercase o), and l (lowercase L) are not present in this Base58 alphabet as they are the previously mentioned characters which might appear ambiguous.

# The relationships between seeds, address and keys

Before we get into the Monero deep, we have to introduce the concept of address generation.

## Elliptic curve

A finite field Fp where p is a prime number, is the field formed by the set {0, 1, 2, ..., p−1}. with arithmetic operations (+, ·) calculated.

Typically, elliptic curves are defined as the set of points (x, y) satisfying an equation:

y^2 = x^3 + ax + b

However, the cryptocurrency Monero uses a special curve known to offer improved security over other commonly used NIST curves, as well as excellent performance of cryptographic primitives.
The curve used belongs to the category of s.c. Twisted Edwards curves, which are commonly expressed as:
ax^2 + y^2 = 1 + dx^2y^2

## Ed25519 Function

## Generating Addresses

### Generating Keys

Monero uses 4 different keys; a set of private and public spend keys and a set of private and public view keys.
In theory these could be two completely seperate pairs of keys but Monero keys have traditionally been generated deterministically since December 2014

To begin generating these pairs of deterministic keys we start by generating the private spend key. This is done by generatign 256 bits of pseudorandom data and then taking that number modulo the prime number 2^255 + 27742317777372353535851937790883648493.
Then, to  generate a deterministic private view key we hash the private spend key with the hashing algorithm Keccak-256 and then take the result of that hash mudulo the previously used prime number.

Finally, to generate public keys from private keys we use eliptic curve multiplication to multiply the ed25519 base point by the secret key represented as a scalar. This is done to derive both the public spend key and the public view key.

### Encoding Addresses

A Monero address is the base58 encoding of a network byte, a public spend key, a public view key, and a checksum.

The network byte identifies which type of address that address is. Mainnet addresses use the network byte 0x12, testnet addresses use 0x13, and subaddresses use the network byte 0x2A.

To get an address checksum, the public view key is concatenated to the public spend key which is concatenated to the network byte  and is then hashed using the Keccak-256 hashing algorithm. The first 4 bytes of this hash is the checksum.

Finally, to get the Monero address the checksum is the concatenated to the rest of the data and is base58 encoded using the previously mentioned base58 alphabet.
