# Chapter 5

# A deep dive into Monero & cryptography

Since long before the birth of computers, mathematics and cryptography have been at the center of communication and information exchange. While simple ciphers have been around since Caesar's time, modern cryptography was born during the World Wars for encrypting important and confidential messages. Initially, governments and militaries funded classified cryptography research to identify protocols for protecting state secrets.

Now, cryptography is no longer limited to spies and militaries; it forms the backbone of communication and security in the internet era, and is widely studied by academic and industry researchers scattered across the globe.

Today, cryptography is a ubiquitous behind-the-scenes tool that enables security, management, communication, and many of the connections that improve our day-to-day lives. For example, consider the invention of Secure Socket Layer (SSL, deprecated in favor of TLS), which is based on cryptographically signing the content. Hospitals, banks, governments, and businesses all protect your data with cryptography. 

This chapter discusses how cryptographic tools can be applied to a decentralized financial database to give rise to cryptocurrencies, especially Monero.

## 5.1 Math fundamentals

Here is a brief introduction/recap of several mathematical principles that are at the core of cryptography.

### 5.1.1 Euclidean Division (A/B)

Dividing any number A by another B, written as A/B or A÷B returns an answer that can either be written as a quotient with a remainder, or as a decimal alone. 

Generally: 
A/B = q with remainder r
For example:
12/4 = 3 with remainder 0, which can be written 3.0 
in decimal form
13/4 = 3 with remainder 1, which can be written 3.25 
in decimal form 
27/5 = 5 with remainder 2, which can be written 5.4 
in decimal form

### 5.1.2 Prime numbers

A prime number is any integer (whole number) that is not divisible by any integer besides '1' and itself. For example: 

**20 is not prime** because it is divisible by 2, 4, 5, and 10, resulting in whole numbers
	e.g. 20 ÷ 4 = 5
	- or -
         20 ÷ 10 = 2
7 is prime because any integer that you divide it by will not yield a whole number besides '1' and itself
e.g. 7 ÷ 3 = 2.3333

Some example prime numbers include 3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837,  145601, 428567, 1171967, and even much larger numbers like 2074722246773485207821695222107608587480996474721117292752992589912196684750549658310084416732550077 or the twin primes 2,996,863,034,895  × 2^1,290,000 ± 1, which have over 350,000 digits each!

### 5.1.3 Modular arithmetic

Modular arithmetic describes numbers that wrap around a particular integer. An intuitive example is the 12-hour clock. If you stay up for 5 hours past 11:00 PM, you would not encounter 16:00 PM o'clock! Instead, at midnight, the time wraps around to zero (so 5 hours past 11:00 PM is 4:00 AM the next day).

Given any two positive numbers, A (the dividend) and B (the divisor),

A modulo B =  the remainder r from A/B. 

In the context of clocks, staying up 5 hours past 11:00 PM could be represented as:

(11:00 PM + 5 hours) mod 12
        = 16:00 mod 12
        = 4:00 (AM)

### 5.1.4 Integer representation

Integers can be represented in many different encodings, several of which are encountered frequently in computer science.

Most people are quite familiar with the base-10 “decimal” system, which represents numbers using 10 characters: 
0,1,2,3,4,5,6,7,8,9.

“Hex” encoding adds 6 extra characters, for a base-16 set: 
0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F.

The integer written as 11719682 in base-10 can be expressed as B2D402 in base-16. Note that a larger character set needs fewer digits (shorter strings) to express the same number.

Computers “think” in base-2, using only the characters “0” and “1.” This is called binary and the number 11719682 (base-10) would be represented as 101100101101010000000010.

Monero prints final addresses and keys in base-58, which uses Arabic numerals and most of the Latin character set (both uppercase and lowercase). It is similar to another scheme called Base64, however it has been modified to avoid numbers and letters that might look ambiguous when printed. Monero uses this format, strictly for the convenience of human users, who often must manually read or transcribe long addresses.

The base-58 alphabet is:
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

Note: Zero (0) along with the letters I (uppercase i), O (uppercase o), and l (lowercase L) are not present in this Base58 alphabet due to their ambiguity with each other.

### 5.1.5 Elliptic curves

#### 5.1.5.1 General introduction

Elliptic curves are defined as the set of 2-dimensional (x, y) points that satisfy an equation:

	y^2=x^3+ax+b.

For example, with fixed coefficients a = 2 and b = 3, this equation becomes

	y^2=x^3+2x+3,

which is satisfied by many pairs of points such as: 

x = 3 and y = 6
x = 3 and y = -6
x = -1 and y = 0.

#### 5.1.5.2 Ed25519 Twisted Edwards

Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, Ed25519, which is the birational equivalent of the Montgomery curve Curve25519.

The ed25519 curve can be expressed algebraically as

	- x^2 + y² = 1 − (121665/121666) x² y².

Thinking back to our general elliptic curve equation, this Twisted Edwards is a special case using the parameters:

 a = -1 and b = 121665/121666.

Recently, it has become clear that a NIST-backed PRNG (Pseudo-random Number Generator Algorithm) is flawed, and contains a potential backdoor. Since the NIST4 standard algorithms have had recent issues, the Twisted Edwards curve was selected to address many concerns held by the cryptography community. 

Seen from a broader perspective, curves selected by the NIST are also implicitly supported by the NSA. These endorsements are viewed suspiciously by the cryptography and cryptocurrency communities due to previous incidents when the NSA used their authority over NIST to weaken algorithms suggested by the latter.

Twisted Edwards curve Ed25519 is not subject to any patents, and the team behind it has developed and adapted basic cryptographic algorithms with efficiency in mind. This curve is currently believed to be secure.

#### 5.1.5.3 Elliptical operations

Elliptic curve point addition and scalar multiplication are fundamental operations for elliptic curve cryptography schemes. It's helpful to have a basic understanding of these concepts before we dive into the mechanics of Monero's calculations.

Elliptic curve point addition operates differently than the typical addition encountered in everyday arithmetic. To add two points together on an elliptic curve you must find the line between those two points and then find the point at which the curve intersects with that line. That point is then reflected over the x-axis to arrive at the final point.

When adding a point to itself, known as point doubling, you must find the tangent line to the starting point to get to the point at which that tangent line intersects with the curve. That point is then reflected over the x-axis to arrive at the final point.

Scalar multiplication utilizes both a point on the curve and an integer. To multiply a point, P, by an integer, S, the point is added to itself S times. Many cryptographic schemes, such as those employed by Monero, use a common base point on the elliptic curve as a generator point to generate public keys from private keys.

When the curve generator point is added to itself many times, the resulting point cannot be used to determine how many times the operation occurred. This problem is often referred to as the elliptic curve discrete logarithm problem. This kind of scalar multiplication is considered a one-way function, since reversing the operation is so difficult.

## 5.2 Cryptography basics

Monero is the leading secure and untraceable cryptocurrency thanks to its unique privacy-oriented cryptographic features, which we'll explore more thoroughly in this chapter. This is one of the more technical chapters of the book, due to the mathematical nature of cryptography. More complex techniques are built upon simple principles known as cryptographic primitives.

A cryptographic primitive is an algorithm that serves as the building block for cryptographic protocols. Monero employs a wide variety of cryptographic primitives for various uses, some of which we covered conceptually in chapters 3 and 4. Monero's intentional approaches to privacy and (ASIC-resistant) proof of work require more sophisticated cryptographic tools than those used by many other cryptocurrencies.

### 5.2.1 Symmetric and asymmetric cryptography

For encrypting data, algorithms can be characterized as symmetric or asymmetric depending on what type of keys are used.

Symmetric encryption requires the participants to share a secret, for example you encrypt a message by the password “hunter2” and the recipient uses the password “hunter2” to decrypt it. To communicate in this way, both parties must have agreed on the shared (symmetric) secret ahead of time. This practical issue limits the utility of symmetric encryption for many applications.

Asymmetric encryption allows two parties to interact securely without sharing a particular secret. This type of cryptography is woven into the framework of internet security, end-to-end messengers, and cryptocurrencies.

Bitcoin uses asymmetric encryption with two keys:

* private key - for signing transactions and for decrypting data
* public key - for signature verification and encrypting data

Monero's more complex cryptographic framework requires four keys:

* public view key - used to verify the validity of addresses
* private view key - used for viewing data such as the balance, 	fees and transactions amounts (the view key cannot create or sign transactions)
* public spend key - another public key for transaction verification
* private spend key - used for signing transactions, i.e. sending moneroj

Your public Monero address is a direct representations of the pair of public keys, whereas Bitcoin (and clones) use a hash of their single public key.  EdDSA keys (both private and public) are 256 bits long, or 64 hexadecimal characters. Not every 256-bit integer is a valid EdDSA scalar (private key); it must be less than the “curve order” described with the equation in the Ed25519 function section. 

### 5.2.2 Hashing

Chapter 4 discussed the concept of hashing and how its uses range from confirming data fidelity to distributing rewards in Proof of Work. Example hashes are shown in the cryptography section toward the end of Chapter 4.

Selecting a good hashing algorithm is crucial for generating addresses and keys in a secure way. If two different inputs produce the same hash output, this is known as a collision. Hashes are commonly used as an identifier in blockchain systems, relying on their effective uniqueness. Furthermore, a collision during seed generation would lead to multiple individuals with the same keys and addresses; obviously this would be extremely problematic!

Monero uses the CryptoNight PoW system, which employs a special CryptoNote hash algorithm, which is built on the Keccak hash. The Keccak algorithm won a NIST competition to be designated SHA3, and is designed by non-NSA engineers. Monero uses the Keccak-256 hashing function with 32-byte output for both transaction and block hashing.

### 5.2.3 Monero pseudorandom number generation (PRNG)

When users and computers are creating new keys, it is crucial that they find new keys that others cannot guess. This is actually a very difficult task, since both hardware and software are typically designed to favor reproducibility. If the computer generates randomness in a predictable way, then the output can be ostensibly random but somewhat easier to guess.

For example consider a PRNG that simply shuffles the digits of the current time to make a 4-digit key. So at “10:34” it might output “0413” or “1403” or “0134” … If you wanted to keep the output key secret, this would be a terrible method for a few reasons:

An attacker who knows that you made your key when you got to work around 12:45 AM would know that the digits “1” and “2” appear, which narrows the choices down to significantly fewer options.

There are no HH:MM times of day with three “9”s. In fact, there are no times with any three digits chosen from {6,7,8,9} since 17:89 h, 18:78 h, etc are impossible times. This rule eliminates many 4-digit pins, leaving the attacker to guess from a much smaller pool.

The above clock-based random number generator is awful because using the time of day as an initial seed is predictable. The initial seed should be much more difficult for an attacker to guess. Good random number generators introduce lots of entropy to make their outputs unpredictable. Simply shuffling 4 digits does not introduce much entropy, another reason that our PRNG above would be insecure.

When generating wallets, the user's operating system provides the initial seed / entropy source. Monero then repeatedly applies the Keccak hashing function, to lead to an unpredictable and non-reproducible output. Each round of hashing produces an output that is used as the input for the next hash.

## 5.3 Generating Monero keys and addresses

### 5.3.1 Picking a seed

In chapter 2 we talked about the heart of your wallet: its seed. Your wallet generates this secret that is used to derive all of your keys, and access/spend your funds. In that overview, we simply considered the 25-word seed mnemonic.  

Behind the scenes, a seed is an unique 256-bit integer from which keys and addresses are derived, for example:

112699108505435943726051051450940377552177626778909564691673845134467691053980
These are often represented as a 64-digit base-16 number, for example:

f9296f587419f1cdede67de160fca14d1069ecaa4c52f012af031eeA09ee039c

(For mnemonic-style keys, this representation of the seed is actually just the private spend key itself!)

Writing down either of the above key styles would be quite difficult, and most people would be prone to make at least one mistake. Conversion to a seed mnemonic phrase is another step included only for human interpretability and usability. The mnemonic phrase essentially converts the above 256-bit number into to a 24-digit (24-word) base-1626 “number” (since there are 1626 words in the seed dictionary). This representation of the long seed strings is much easier to read: 

lamb hexagon aces acquire twang bluntly argue when unafraid awning academy nail threaten sailor palace selfish cadets click sickness juggled border thumbs remedy ridges border

When your wallet presents the 24-word seed, it adds a 25th word that functions as a checksum, which allows later detection of typos or mistakes. Monero's mnemonic method encodes with a minimum 4:3 ratio. In other words, four bytes creates three words, plus one checksum word; eight bytes creates six words, plus one checksum word; and so on.

The private view key is derived by hashing the seed with Keccak-256, producing a second 256-bit integer, which is then sent to the function called sc_reduce32 to ensure that it is compatible with the elliptic curve. The seeds created by this method will always be valid scalars as they are sent to sc_reduce32 first. 

### 5.3.2 Key derivation

#### 5.3.2.1 All keys

The Monero seed described above is actually your secret spend key, from which all other keys are derived. The secret view key is the reduced hash of your secret spend key, converted to a valid scalar for the ed25519 curve.

These two private keys are multiplied by the generator point to yield the two public keys for your wallet (public spend and public view). This method for derivating keys is referred to as the deterministic method.

#### 5.3.2.2 View-only wallets

You can grant view-only access to a Monero account by setting up a wallet with your secret view key, but NOT the secret spend key. These view-only wallets can see all incoming transactions, but cannot spend moneroj or see outgoing transactions.

There are several situations in which it is useful to check incoming transactions without send access. For instance, individuals with cold wallets can use the view key to check that funds arrived, while keeping their secret spend key safely sequestered away. Likewise, developers can build systems that can detect and respond to incoming payments, without needing to have the ability to move those funds.

This feature is especially valuable for charities, which can share their view key to ensure transparency and accountability around donations. If you make a donation to the a public address, you can use the view key to verify that the charity received your funds.

For example, consider the Monero General Fund donation address: 
44AFFq5kSiGBoZ4NMDwYtN18obc8AemS33DBLWs3H7otXft3XjrpDtQGv7SqSsaBYBb98uNbr2VBBEt7f2wfn3RVGQBEP3A. 

Since stealth addresses prevent that public address from being recorded or searchable on the blockchain, the community also publishes the view key (f359631075708155cc3d92a32b75a7d02a5dcf27756707b47a2b31b21c389501) so that the public can review donation activity.

Since anybody with the view key can see the total amount that a wallet has received, a transparent charity that has been gifted 100 XMR cannot divert 90 XMR and claim that they only received 10 XMR. This functionality is especially valuable for crowdfunding situations where a certain donation threshold must be reached.

The inability to see outgoing transactions from a view-only wallet is a feature, not a bug! If the outgoing transactions were made public, it would reveal when an output has been spent. This would be very problematic, since ring signatures rely on spend state ambiguity. Suppose a charity reveals when an output is spent; all appearances in future (and previous) ring signatures can be identified as decoys. Not exposing outgoing transactions is thus necessary for maintaining the integrity of overall network privacy.

The view-only wallet feature of Monero may also prove to be Monero's protection against regulation that would attempt to ban Monero in certain jurisdictions. Since individual Monero users can choose to share their private view-key, they could choose to provide it to auditors to verify their funds. This would be a reasonable approach to appeasing auditors and as a result, relinquish fears that Monero could not work within the paradigms of existing financial structures.


### 5.3.3 Address generation

A Monero wallet's standard address is composed of the two public keys (the public spend key + public view key) derived in the last section. It also contains a checksum and a network byte which identifies both the network and the address type.
 
#### 5.3.3.1 Network byte

The network byte is used differentiating between various cryptocurrencies and networks. CryptoNote coins specify the appropriate values in the file src/CryptoNote_config.h, for example

uint64_t const CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 18;

Monero's main network uses '18' to indicate a primary address (this is why Monero primary addresses begin with a '4,' which is the ASCII  representation).  Monero developers use the testnet and stagenet, which have their own unique network bytes:

Name | Code Value | ASCII value
-- | -- | --
Main net primary address |	18 |	4
Main net subaddress	| 42 |	8
Test net primary address |	53 |	9
Test net subaddress |	63	| B
Stage net primary address	| 26	| 5
Stage net subaddress	| 36	| 7

#### 5.3.3.2 Concatenated public keys

The public spend key and public view key are concatenated and appended to the network byte, to produce the raw address (everything except the checksum). While this address is still in a raw format, it contains all of the key information: keys for crafting transactions and network metadata to ensure that transactions are announced to the correct network.

#### 5.3.3.3 Checksum

Since Monero transactions are non-reversible, it's crucial to send payments to the right address! To help avoid typos and minor mistakes, the address includes a checksum. If the sender makes a typo or doesn't capture the whole address, the checksum will not match, indicating that the string entered is not a valid address.

This checksum is generated by Keccak hashing the address information collected in the previous section. The hash digest is shortened to the first 4 bytes, and used as the checksum.

#### 5.3.3.4 Bring it all together: address finalization

Lastly, the network byte, keys, and checksum are concatenated according to Monero specification:

| Index |	Sizes in bytes  |	Description
-- | -- | --
0 |	1 |	identifies the network and address type - '18' for mainnet and '53' for the testnet (in base-58, '4' and '9' respectively)
1 |	32 |	public spend key
33 |	32 |	public view key
64 |	4 |	checksum (hash created with Keccak function of the previous 65 bytes, trimmed to first 4 bytes)

Lastly, this 69-byte output string is encoded into the Monero base-58 format. This conversion increases the length to a 95-character string that is easy to read and write. That's all there is to it! Monero primary addresses simply contain:

[network byte + public spend key + public view key + checksum]
Example standard address:
4BKjy1uVRTPiz4pHyaXXawb82XpzLiowSDd8rEQJGqvN6AD6kWos LQ6VJXW9sghopxXgQSh1RTd54JdvvCRsXiF41xvfeW5

The pseudo-code below describes the process of generating a public address, using Hs() to represent Keccak hashing and '||' to represent string concatenation.

  Checksum = Hs(Varint(Prefix) || public spend key  || public view key) 
  SerializedString = Base58(Prefix || public spend key || public view key || checksum)

Chapter 7 includes actual Python code for generating keys and addresses yourself!

### 5.3.4 Subaddresses

Privacy for Monero transactions is achieved by three primary constructions: ring signatures, stealth (one-time) addresses, and RingCT. These mitigate the risk of transactions being linked by analyzing blockchain data. However, one must consider risks of “off-chain” linkability (in other words, information collected from other sources besides the blockchain data itself).

For example, suppose your primary address has received payments from several different individuals. Thanks to Monero's stealth address technology, your public address is never explicitly recorded in transactions, so nobody can link to those transactions from analyzing the blockchain (including the spenders). However, this cryptographic privacy is entirely circumvented if two of your senders communicate with each other and discover that they have both been sending moneroj to the same address!

You can avoid this risk by generating multiple subaddresses, sharing a unique one with each sender. The subaddresses are derived from the same keys as your primary address, so funds received to any subaddress will route to the same overall wallet balance. However the various subaddresses are cryptographically unlinkable, so multiple people sending moneroj to the same wallet cannot recognize this by comparing their address lists.

#### 5.3.4.1 Creating a subaddress

Recall that each wallet has two pairs of keys. The private view key (pV0) and private spend key (pS0) are kept secret, while the public view key (PV0) and public spend key (PS0) are encoded into each address.  As discussed, the public keys are generated by multiplying the private keys by the generator point (G) on the elliptic curve, i.e. (PV0, PS0) = (pV0, pS0)G.

Your wallet can create a vast number of subaddresses, each with a different index 'i' (typically starting at i=1). Each subaddress will have its own sets of keys at each index, with unique private (pVi, pSi) and public (PVi, PSi) keys.

The formula to create a public spend key for the ith subaddress is:

	PSi = Hs(pV0||i)G+PS0

This process begins by concatenating the index 'i' to the primary address private view key (pV0), and passing that result through the hash_to_scalar function (note: in practice, the reference client wallet also concatenates the string SubAddr to the data, as a common salt for the hashing). The resulting scalar is multiplied by the curve generator point and added to the  primary public spend key through elliptic curve point addition.

This subaddress public spend key is multiplied by the primary private view key to yield the subaddress public view key:

	PVi = pV0*PSi

The subaddress public keys are encoded into the public address following the same convention as primary addresses:

	Subaddress_i = base58(network byte || PSi || PVi || checksum)

However, the mainnet network byte for subaddresses is 0x42, which is why they all begin with the digit '8'.

#### 5.3.4.2 Sending to a subaddress

This different identifying first network bit is crucial, since transactions to subaddresses must be constructed slightly differently than normal.

When constructing a transaction, wallets typically generate 32 random bytes to serve as the private key. When sending to a primary address, this random key is multiplied by the elliptic curve generator point through elliptic curve scalar multiplication to yield the transaction public key. However, when sending to a subaddress, the private transaction key is instead multiplied by the public spend key of the receiving subaddress.

#### 5.3.4.3 Receiving to a subaddress

Due to the obfuscated nature of the Monero blockchain, a wallet must scan every transaction to ascertain whether it belongs to the owner.
To ascertain whether a given output X (with public transaction key R) was sent to the primary address, the wallet checks calculations based on its public view key and public spend key. If the equality X==Hs(pV0* R)G+PSi is true, then that output can be unlocked and spent!

However, the process is slightly different to check which outputs belong to subaddresses. The calculation is mostly the same, except that the hash_to_scalar term is subtracted from the output and compared against subaddress public spend keys. The wallet knows it has found on output that it owns, if the equality PSi == X - Hs(pV0 * R)G is true.

### 5.3.5 Other methods for key derivation

To add to the confusion, there are presently at least 3 different methods of private key derivation used in Monero (this is also the case for Bitcoin). These methods vary in a few important ways:

* **Original** (non-deterministic style): The private spend key and private view key are both independently and randomly chosen to form an account. There is no good way to backup a non-deterministic account, other than retaining copies of each file. Due to better alternatives, this unwieldy method is no longer recommended.

* **Mnemonic** (deterministic or “Electrum”) style: In this style, all of the keys are derived from a single private spend key, which is referred to as the seed. The private view key is derived by hashing the private spend key with Keccack-256 to produce a valid EdDSA scalar. These accounts are easy to backup, since you only need to write down the seed (which is usually expressed as a base-1626 mnemonic phrase).  

* **MyMonero Style**: The MyMonero wallet family uses a method similar to the Electrum convention, however the seed phrase is 13 words instead of the usual 25 words. The 13 words convert to a 128-bit integer that is used for both spend and view key derivation. The seed integer is hashed with Keccak-256 and converted to the private spend key. This private spend key is hashed again with Keccak-256 and converted to the private view key.

You may have noticed a critical difference between the MyMonero and Electrum seed styles. MyMonero creates the private view key by hashing a random integer, whereas the Electrum style hashes the private spend key. This means that the 13 and 25 word seeds are not compatible - it is not possible to create an Electrum-style account that matches a MyMonero-style account (or vice versa) because the view keypair will always be different.

## 5.4 The privacy technologies

### 5.4.1 Stealth address

Chapter 3 conceptually described how one-time addresses, also known as  stealth addresses, allow transactions to be posted to the network without revealing the recipient's true address. This section will go deeper to explain the cryptography behind that one-time public key.

#### 5.4.1.1 Sending

The CryptoNote protocol calculates the receiving one-time address according to the formula X = Hs(r* PV|i)G + PS. Let's step through the meaning of these symbols, and how Maria would generate a one-time address when she sends money to George.

The variable r is the transaction private key, which is a 256-bit pseudorandom scalar. Maria (the sender) is the only person that will ever know this key; even George (the recipient) never learns the random number that Maria's wallet chose for r.

Maria then multiplies George's public view key, PV, by r and then appends the output index, i. This quantity (r* PV|i) is then run through the hash_to_scalar function, Hs(). This function hashes its inputs using the Keccak-256 algorithm, then takes that resulting hash modulo the prime number 
2^255 + 27742317777372353535851937790883648493.

The Hs(r* PV|i) term calculated in the above paragraph is multiplied by The ed25519 basepoint, G. Lastly, Maria adds this quantity to George's public spend key, PS, to produce the final output, X, which is the stealth address.

This convoluted process allows Maria to hide the transaction to George on the blockchain, using a randomly-generated one-time address that nobody will be able to connect to him.

#### 5.4.1.2 Receiving

Given how well Maria hid the moneroj that she was sending to George (obscured by a transaction private key that even George doesn't know), you might wonder how he can find it on the blockchain!

As described in chapter 3, George must scan the blockchain for outputs that belong to him. The process is very similar to the method that Maria used to generate the address.

George takes the public transaction key R from the blockchain, and multiplies it by his private view key, pV. Following similar steps as Maria, George appends the output index i and then applies the hash_to_scalar function to (pV*R|i). He then multiplies the result by G and adds his own public spend key, PS. If this value matches the output, then it belongs to him.

In other words, George's wallet scans over every transaction in the blockchain to identify outputs for which X = Hs(pV* R|i)G + PS.

### 5.4.2 Ring Confidential Transactions

Ring Confidential Transactions (RingCT) obscure the amount of moneroj being sent in a transaction. RingCT was implemented in January 2017 and became mandatory in all transactions after September 2017.

Only transactions that mint new moneroj as coinbase rewards have visible amounts, not masked by RingCT. This is an auditing feature that allows any network participant to count and verify exactly how many moneroj have been generated. After this public coin emission, these transactions are converted to RingCT outputs before further use.

All non-coinbase transactions employ RingCT to encrypt the transaction amount. The amount for each transaction is encrypted two different ways, which are both included in the message.

First, the amount is encrypted by a key derived from the public information in the recipient's address. This version is recorded in the ecdhInfo field, and can only be decrypted and read by the recipient, using the transaction shared secret.

Secondly, the amount is integrated into a Pedersen commitment, which allows other Monero users to verify the validity of the transaction themselves. Nobody can retrieve the transaction amount from the Pedersen commitment, however anybody can inspect the result to mathematically verify that the outputs balance the inputs. This prevents any transactions attempting to forge moneroj.

There are two key aspects to RingCT verification:

1. The sender verifiably proves that all outputs contain a positive amount, using a range proof. The range proof demonstrates that the masked number can be generated as the sum of positive powers of 2, without revealing what those powers are. Without range proofs, a sneaky user with 5 XMR could create a transaction with a pair of outputs containing +13 XMR and -8 XMR.

2. The sender also demonstrates that the inputs balance the outputs, which is non-trivial given that ring signatures contain decoys to prevent the verifying party from knowing the true source of the input funds! Homomorphic Pederson commitments enable the sender to prove that one of the potential inputs has a zero difference with the outputs, without revealing the amount in the process.

For a simple analogy, consider the following example equations. Like masked transaction amounts, you can verify that whether each equation is valid without knowing the value of A.

A = our output, nobody knows that

5A + 1A + 4A = 10A 	TRUE! Verified, without knowing A

6A + 4A + 2A = 14A	FALSE! Not verified, rejected!

### 5.4.3 Ring signatures

Monero utilizes ring signature technology to protect the privacy of each transaction's sender. A ring signature is a type of cryptographic signature that allows one active participant to sign a message on behalf of a group. The private key owned by the active signer is mixed with public key information from the other members to produce a single signature. Anybody can validate the signed message against the public keys to verify that one of the ring members initiated the signature, however it is impossible to ascertain which member contributed the private key.

In the context of Monero, the message is a transaction, authorized by the ring signature. The output that is actually being spent is the true signer, and the public keys from other outputs (from past transactions) are mixed in as decoy signers. The actual signer and decoy signers are mathematically equally valid; the resulting ring signature cannot be cryptographically examined to determine which member actively initiated the signature. Consequently, no outside party (including the recipient) can ascertain which of the outputs referenced in a transaction was actually spent.

Every ring signature produces a single key image that is derived from the output actually being spent. This is a cryptographically-secure process: each output corresponds to a single key image, and producing the key image does not reveal the true signer in the ring.

When the owner of an output spends it in a new transaction, the network stores the key image that was produced by the ring signature. Since the network cannot identify which outputs are spent, it instead keeps track of which key images are spent! If the owner tried to fraudulently spend the output again, the same key image would be produced, so the network knows to reject the transaction.

Let's dig into the actual mathematics of generating a ring signature. Throughout this example, let HS be a hash function that returns scalars (in the appropriate field) and HP be a hash function that returns points (in the appropriate curve group). We purposely avoid formally defining these domains and codomains to avoid complication. Let G be a fixed point known to all parties.

You are going to sign the transaction message M with a ring signature. Monero currently requires eleven ring members for each signature, however let's consider a simplified example with three ring members. You have the keypair (public and private) for the output that you are spending, and select two other outputs (and their public keys) to serve as decoys. Naturally the indexing of the ring members should be randomized, since the cryptographic anonymity would be circumvented if the true signer was always in slot #1.  For the simplified example with three ring members, suppose your wallet has randomly selected to put the true source of the funds in slot #2.

You retrieve the public output keys for the decoys (P1 and P3) from the blockchain, and you have both the private key (p2) and the public key (P2 = p2G) for the output that you are spending. You start by choosing a random number u, which you will later discard. First you form the following commitment, starting at the index after the one you picked for your key:

	c3 = Hs(M,uG,uHp(P2))

To form the rest of the commitments, you also choose random numbers s3 and s1 that you'll need later:

	c1 = Hs(M,s3G + c3P3 , s3Hp(P3) + c3p2Hp(p2))

Notice that you are including several pieces of information here: the public key P3 you plucked from the blockchain, the random number s3 you came up with, the previous commitment c3, and a value p2 Hp (P2) formed from your own key. You keep going:

	c2 = Hs(M, s1G + c1P1, s1Hp(P1) + c1p2Hp(P2))

But you are not quite done! To hide where your actual key is, you cleverly define s2 = u − c2 p2. The signature you send to the blockchain and the world contains several quantities: (c1 , s1 , s2 , s2 , J), where J = p2Hp(P2) is the key image used in each commitment. We rename it here to highlight the fact that the public doesn't know the pieces that were used to form it.

Here's why this is clever: by setting s2 = u − c2 p2, you can rearrange to see that u = s2 + c2p2 . This means that the public sees the first commitment c3 that you made as the following:

	c3 = Hs(M, s2G + c2P2, s2Hp(P2) + c2p2Hp(P2))

This looks exactly like the other commitments! Although you never broadcast u, you use it to cleverly make each commitment look identical in the eyes of observers. This is the power of the ring signature. Nobody can ascertain which commitment hides your true key, but everybody can mathematically verify for themselves that:

* the sender knew one of the private keys represented by the public keys
* the key image was computed correctly

Observe that the key image J = p2Hp(P2) was uniquely calculated from the true output's keypair, without any random numbers or decoys' public keys. Thus, any fraudulent attempts to spend the output a second time will generate an identical key image. Since the network keeps track of which key images have been used, any attempts to reuse outputs are easily detected and rejected.

Note that the above example of a Back-style LSAG ring signature is included for educational purposes, and should not be used as a reference document for production implementations.

### 5.4.4 Further resources

If you want to venture even further into the calculations behind these technologies, check out 'Zero to Monero', by Alonso, K.M. & Koe. This book is a highly-technical mathematical tour that is also available as a free community-funded PDF.

## 5.5 The Monero blockchain

By now you're familiar with the importance and utility of blockchains as distributed public ledgers. These blocks are structured and ordered into an immutable append-only database, secured by cryptographic tools that prevent any tampering or cheating. Monero's blockchain is unique and we'll discuss its technology and specifications in this section.

### 5.5.1 Lightning Memory Mapped Database

Monero uses the Lightning Memory Mapped Database (LMDB) system to store its blockchain. LMDB is a software library that provides a high-performance embedded transactional database in the form of a key-value store. This means that it is highly effective, and easy to search.

LMDB is written in C++ with API bindings several programming languages, and is developed by Symas Corporation. Here are a few LMDB features:

* Arbitrary key/data pairs storage as byte arrays 
* Range-based search capability
* Support for a single key with multiple data items
* Advanced methods for appending records at the end of the database, which gives a dramatic write performance increase over other similar stores

### 5.5.2 The structure of a block

The CryptoNote standards define specifications for storing and delineating data within blocks and on the blockchain. The block structure contains three main components:

* The block header
* The base transaction
* A list of transaction identifiers (hashes of transactions mined in the block)

#### 5.5.2.1 The block header

Each block starts with a header that contains key metadata. The “major_version” defines the block header parsing rules, so it can be interpreted correctly. The “minor_version” defines the interpretation details that are not related to the main header parsing.

Even if the minor version is unknown, it is always safe to parse the block header of a particular major version. Parsing the block header with an unknown major version is risky, since the contents of the block header may be misinterpreted.

Field |	Type |	Content
-- | -- | --
major_version | 	varint |	Major block header version
minor_version | 	varint |	Minor block header version
timestamp	| varint	| Block creation time (UNIX timestamp)
prev_id |	hash |	Identifier of the previous block
nonce |	4 bytes | Any value which is used in the network consensus algorithm

#### 5.5.2.2 Base Transaction

Each valid block contains a single base transaction that routes its coinbase reward to the miner. The base transaction must follow the coin emission rules, and include the block height field.

#### 5.5.2.3 List of transaction identifiers

Field | Type | Content
--|--|--
version |	varint|	Transaction format version
unlock_time |	varint|	UNIX timestamp.
input_num |	varint|	Number of inputs. Always 1 for base transactions.
input_type |	byte|	Always 0xff for base transactions
height |	varint|	Height of the block which contains the transaction
output_num |	varint|	Number of outputs
outputs|	array |	Lists of outputs as array

The base transaction is followed by a list of transaction identifiers. These identifiers are calculated by taking the Keccak hash of the transaction body. The list starts with the number of identifiers and is followed by the identifiers themselves (if the block is not empty).

#### 5.5.2.4 Calculation of Block Identifier

The identifier of a block is produced by hashing the following data with Keccak-256:

* size of block_header
* block_header
* Merkle root hash
* number of transactions (varint)

The Merkle root hash “attaches” the transactions referenced in the block's body to the block header: once the Merkle root hash is fixed, the transactions cannot be modified. This security feature keeps blockchains safe from tampering or any kind of retroactive modification.

### 5.5.3 The mining economy

Block rewards and fees were mentioned conceptually in chapters 2 and 4. Now you'll actually learn about the complexities of block sizes, rewards, and the relationship with fees.

#### 5.5.3.1 Mining coinbase reward

As discussed in Chapter 4, all moneroj originate as rewards paid to miners for successfully completing blocks. The size of this coinbase payment depends on the current supply (A) and the initial number of atomic units (S = 264 - 1).  An atomic unit is the smallest division of Monero currently recognized by the network (1x10-12 XMR)

	Base Reward = 2 * ((S - A) * 2-20 * 10-12)

Monero has a tail emission, which is a small fixed base reward that will continue after most of the supply has been mined. Monero's minimum base reward is 0.6 XMR per block, so miners will never have to subsist on fees alone.

#### 5.5.3.2 Dynamic block size

Monero has a dynamic block size, which allows for continuous adjustment as the network grows, in contrast to many cryptocurrencies that use a static (fixed) block size. For example, Bitcoin's initial 1 MB fixed block size caused scaling issues, by limiting the number of transactions that could be included in each block (consequently limiting the overall transaction volume for the network). In 2017, this bottleneck resulted in periods with extremely high fees and delayed processing of transactions. Various proposed solutions were put forth, resulting in a period of contentious debate.

To avoid these issues, Monero uses a dynamic block size mechanism that allows the miners to use larger blocks to accommodate increased traffic. However, if the block size was left entirely unconstrained, the Monero network could be vulnerable to spam attacks, i.e. lots of small transactions designed to exhaust network and storage resources by making the blockchain expand too rapidly.

To prevent excessive blocksize growth, Monero mining protocols includes a penalty function that decreases the coinbase reward for oversize blocks. The original CryptoNote authors included this consensus rule to limit the rate of block size expansion and avoid rapid blockchain bloat.

If a block is mined with size (B) that is is larger the median size of the last 100 blocks (MN), part of the base reward is withheld, according to:

Penalty = BaseReward * ((B / MN) - 1)2

Miners receive the full reward for any sized block up to 300 kB; for anything larger, the penalty function “kicks in”. The maximum block size is 2* MN, at which point the entire coinbase is withheld.

#### 5.5.3.3 Fees

When transaction volume is low and block sizes are small, miners are rewarded with the full coinbase, and fees are minimal.

However, imagine a different scenario: What happens if the median size of the last 100 blocks grows larger than the penalty-free block size (300 kB)? Then, the dynamic fee algorithm comes into play!

Fees are calculated by the weight of the transactions in kB. Larger (“heavier”) transaction incur a higher fee. The dynamic fee calculation is complex, taking into account several factors of the Monero ecosystem, and the transaction's priority (the sender can incentivize miners to quickly include an urgent transaction by attaching a larger fee). The fees necessary to be competitive in an upcoming block are calculated according to:

	Fee per kB = (R/R0) * (M0/M) * F0 * (60/300) * 4

* R is the base reward
* R0 is the reference base reward (10 XMR)
* M is the block size limit
* M0 is the minimum block size limit (300 kB)
* F0 is 0.002 XMR
* 60/300 is the adjustment factor to account for the increase of the penalty-free block size limit (adjusted from 60 kB to 300 kB in 2017)
* 4 is the adjustment factor to account for the default fee multiplier (the lowest fee level uses a multiplier of x1, and a normal priority transaction uses x4)

Thus, the fees take into account the increase in the median block size relative to the minimum block size. For example, a 600 kB block size (twice the minimum) reduces the fees by half.

Ideally, an increase in Monero's exchange rate and usage would result in a reduction of absolute fees (i.e. in terms of XMR). This fee reduction mechanism has less effectiveness during extreme price increases that are disproportionately larger than the increase in transaction volume (and thus block size).

The dynamic fee algorithm is designed to function when the median block size is consistently above 300 kB. While the system is intended to account for increases in price, usage is not perfectly correlated with price, and is thus an imperfect proxy.

### 5.5.4 Bulletproofs

Bulletproofs are a new feature that dramatically decreases transaction size, which in turn reduces the overall fees per transaction! Monero transactions used to be quite large (usually > 12 kB), so bulletproofs were a much-anticipated enhancement.

Monero's privacy features necessitate several complex “tests” during transaction validation, in order to prevent abuse and spam. This includes verification of masked amounts, checking fees, and confirming that no double spends are occurring.

Most developers have encountered “overflow” errors, when an operation creates a value outside the range that can be represented. Unfortunately, “infinite” is an abstract concept for electronics, which encounter many obstacles with large numbers.

Since RingCT hides the transaction amounts, complicated calculations are necessary to verify that the inputs and outputs balance properly. The useful algebraic properties of commitments are valuable for enabling masked transactions whose validity can be confirmed by any participant.

However, it is also crucial to ensure that each amount is a positive value that will not cause an overflow. This is where range proofs come in, by allowing anybody to verify that a commitment represents an amount within a specified range, without revealing anything else about its value. Each range proof used to require ~ 7 kB, so they made up the bulk of a transaction's size. Most transactions have two outputs (the destination and change address) necessitating at least ~12 kB.

Bulletproofs employ some clever mathematical tricks to construct the range proof with a more efficient mechanism. This reduces the size of a single range proof to ~2 kB!

Before bulletproofs, transactions with multiple outputs required multiple separate range proofs. Consequently, transaction size scaled linearly with the number of outputs (e.g. 1 output = 7 kB, 2 outputs = 14 kB). With bulletproofs, size instead scales logarithmically with more outputs (e.g. 1 output = 2 kB, 2 outputs = 2.5 kB).

By reducing the size of each range proof, and allowing them to combine in a more efficient way, bulletproofs dramatically decrease transaction size, and thus fees. Bulletproofs were enabled by the Monero v0.13.0 network upgrade in October 2018, as an opt-in feature that will become mandatory during the subsequent upgrade.

## 5.6 Fungibility

As you can see, Monero uses several highly sophisticated encryption protocols to secure its network and adhere to the fundamental principles of privacy and decentralization. With the help of the Monero Research Lab and various auditing agencies, Monero will continue to identify and validate cutting edge encryption technology to make the technology as fast, secure, private, and efficient as possible.

One of the key features of money is the feature known as fungibility. Fungibility means that one piece of value is equal to another piece of value of the same amount. One ounce of gold equals one ounce of gold. Or in our case, one moneroj equals one moneroj. The encryption protocols used by Monero make it fungible and allow it to reach its goal of being true, digital money.

Cryptocurrencies that are transparent at their base layer do not have these encryption layers in place and as a result, are not fungible. A coin that can be traced to the dark net will be tainted and coins that are newly minted or sold on auction by law enforcement might be sold at a premium. So in the case of transparent cryptocurrencies, one coin does not equal the same value as another coin of the same amount. They are not fungible. This is truly problematic in the goal of being digital money.

So beyond maintaining good security, privacy, and decentralization through Monero's sophisticated encryption protocols, it also ensures fungibility, an essential component of sound money.
